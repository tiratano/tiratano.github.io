<!DOCTYPE html>
<meta charset="utf-8" xmlns="">
<html>
<head>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font: 10px sans-serif;
        }

        .axis path,
        .axis line {
            fill: none;
            stroke: #000;
            shape-rendering: crispEdges;
        }

        .x.axis path {
            display: none;
        }

        .line {
            fill: none;
            stroke: steelblue;
            stroke-width: 1.5px;
        }
    </style>
</head>

<body onload="init()">

<div>
    <div>
        <h1>일별 확진자수 / 양성률 / 볼린저 밴드</h1>
    </div>
    <svg id="chart1"></svg>
</div>

<div>
    <div>
        <h1>연령대별 확진자 수 / 양성률</h1>
    </div>
    <svg id="chart2"></svg>
</div>

<div>
    <div>
        <h1>백신 접종자 수</h1>
    </div>
    <svg id="chart2"></svg>
</div>

<script>
async function init() {
    // Source: COVID-19 (coronavirus) by Our World in Data
    // https://github.com/owid/covid-19-data/tree/master/public/data
    const data = await d3.csv('./covid_kor_all.csv');

    var width = 900;
    var height = 200;
    var top_margin = 0;
    var margin = 50;

    var state_date = data.map((v) => { return v['date']; })
    var new_cases = data.map((x) => { let v = x['new_cases']; if (v == "") return 0; return Number.parseInt(v); })
    max_val = new_cases.reduce((a, b) => Math.max(a, b), 0);

    var parseTime = d3.timeParse("%Y-%m-%d");
    var dates = [];
    for (let obj of data) {
        dates.push(parseTime(obj.date));
    }
    var domain = d3.extent(dates); // date: from ~ to
    domain[1] = parseTime('2021-08-01'); // set end date to 2021-08-01
    var xScale = d3.scaleTime().domain(domain).range([0, width]);
    var xAxis = d3.axisBottom(xScale);

    var x = d3.scaleBand().domain(Array.from(Array(dates.length).keys())).range([0, width]);
    var x_invert = d3.scaleBand().domain(Array.from(Array(dates.length).keys())).range([width, 0]);

    var y = d3.scaleLinear().domain([0, max_val]).range([height, 0]);
    var y_invert = d3.scaleLinear().domain([0, max_val]).range([0, height]);

    var ys = d3.scaleLinear().domain([0, 1]).range([0, height/max_val]);
    var vis = d3.select("#chart1")
        .attr("width", width + 2 * margin)
        .attr("height", height + top_margin + margin);

    vis.append("g")
        .attr("transform", "translate(" + margin + "," + top_margin + ")")
        .selectAll("rect").data(data)
        .enter().append("rect")
        .attr("x", function (d, i) {
            return x(i);
        })
        .attr("y", function (d) {
            return y(d.new_cases);
        })
        .attr("width", 1)
        .attr("height", function (d) {
            return ys(d.new_cases);
        })
        .style("fill", "steelblue");

    // y axis
    d3.select("#chart1")
        .append("g")
        .attr("transform", "translate(" + margin + "," + top_margin + ")")
        .call(d3.axisLeft(y));

    // x axis
    d3.select("#chart1")
        .append("g")
        .attr("class", "xaxis")
        .attr("transform", "translate(" + margin + "," + (height + top_margin) + ")")
        .call(
            xAxis.ticks(d3.timeMonth)
                .tickFormat(d3.timeFormat("%Y-%m-%d"))
        );

    // x axix > rotate 45 degrees
    vis.selectAll(".xaxis text")
        .attr("transform", function(d) {
            return "translate(" + this.getBBox().height*-2 + "," + this.getBBox().height + ")rotate(-45)";
        });

    //////////////////////////////////////////////////
    // mouse actions
    //////////////////////////////////////////////////
    var color = d3.scaleOrdinal(d3.schemeCategory10);
    var mouseG = vis.append("g")
        .attr("class", "mouse-over-effects");

    mouseG.append("path") // this is the black vertical line to follow mouse
        .attr("class", "mouse-line")
        .style("stroke", "black")
        .style("stroke-width", "1px")
        .style("opacity", "0");

    var lines = document.getElementsByClassName('line');

    var cities = color.domain().map(function(name) {
        return {
            name: name,
            values: data.map(function(d) {
                return {
                    date: d.date,
                    temperature: +d[name]
                };
            })
        };
    });

    var mousePerLine = mouseG.selectAll('.mouse-per-line')
        .data(cities)
        .enter()
        .append("g")
        .attr("class", "mouse-per-line");

    mousePerLine.append("circle")
        .attr("r", 7)
        .style("stroke", function(d) {
            return color(d.name);
        })
        .style("fill", "none")
        .style("stroke-width", "1px")
        .style("opacity", "0");

    mousePerLine.append("text")
        .attr("transform", "translate(10,3)");

    mouseG.append('svg:rect') // append a rect to catch mouse movements on canvas
        .attr("transform", "translate(" + margin + "," + top_margin + ")") // 마우스 캡쳐할 영역도 margin 고려해야 함.
        .attr('width', width) // can't catch mouse events on a g element
        .attr('height', height)
        .attr('fill', 'none')
        .attr('pointer-events', 'all')
        .on('mouseout', function() { // on mouse out hide line, circles and text
            d3.select(".mouse-line")
                .style("opacity", "0");
            d3.selectAll(".mouse-per-line circle")
                .style("opacity", "0");
            d3.selectAll(".mouse-per-line text")
                .style("opacity", "0");
        })
        .on('mouseover', function() { // on mouse in show line, circles and text
            d3.select(".mouse-line")
                .style("opacity", "1");
            d3.selectAll(".mouse-per-line circle")
                .style("opacity", "1");
            d3.selectAll(".mouse-per-line text")
                .style("opacity", "1");
        })
        .on('mousemove', function(event) { // mouse moving over canvas
            var mouse = d3.pointer(event);
            d3.select(".mouse-line")
                .attr("d", function() {
                    var d = "M" + (mouse[0] + margin) + "," + height;
                    d += " " + (mouse[0] + margin) + "," + 0;
                    return d;
                });

            d3.selectAll(".mouse-per-line")
                .attr("transform", function(d, i) {
                    console.log(width/mouse[0])
                    var xDate = x_invert(mouse[0]), // x.invert(mouse[0]),
                        bisect = d3.bisector(function(d) { return d.date; }).right;
                    idx = bisect(d.values, xDate);

                    var beginning = 0,
                        end = lines[i].getTotalLength(),
                        target = null;

                    while (true){
                        target = Math.floor((beginning + end) / 2);
                        pos = lines[i].getPointAtLength(target);
                        if ((target === end || target === beginning) && pos.x !== mouse[0]) {
                            break;
                        }
                        if (pos.x > mouse[0])      end = target;
                        else if (pos.x < mouse[0]) beginning = target;
                        else break; //position found
                    }

                    d3.select(this).select('text')
                        .text(y_invert(pos.y).toFixed(2));

                    return "translate(" + mouse[0] + "," + pos.y +")";
                });
        });
}
</script>

</body>
</html>
